##  一、关于作业
#### 1.图像旋转

参考博客：

https://blog.csdn.net/liyuan02/article/details/6750828

https://blog.csdn.net/lkj345/article/details/50555870

https://www.cnblogs.com/linkr/p/3630902.html

要点：旋转公式、映射关系（前向映射，反向映射）、插值方法（双线性插值（推荐）、最邻近插值）

算法：

```
function rotated_img = my_imrotate(img, angle)   

row,col,d = 获取图像行列以及通道维度 (img）

new_row =根据angle以及row,col 计算旋转后图像的大小的 新 row

new_col = 根据angle以及row,col 计算旋转后图像的大小的 新 col

rotated_img[] = 为旋转后的图片开辟空间，大小由new_row,new_col,d决定，注意数据格式为uint8


for  x=1:new_col

	for y=1:new_row

		x0= 根据旋转公式（angle,new_row,new_col ）计算出旋转后图中 坐标x 在原始图像中对应的坐标x0

		y0= 根据旋转公式（angle,new_row,new_col ）计算出旋转后图中 坐标y 在原始图像中对应的坐标y0

		x00=  x0四舍五入

		y00=  y0四舍五入

		if  x00>1 && y00>1 && x00<col && y00<row

			x_small= x00向下取整

			x_large= x00向上取整

			y_small= y00向下取整

			y_large= y00向上取整

			point1= 利用双线性插值计算出行数为y_small 列数为x0上的插值

			point2= 利用双线性插值计算出行数为y_large 列数为x0上的插值

			point3= 利用双线性插值计算出行数为y0 列数为x0上的插值

			rotate_img[]=point3

		end

	end

end

end
```

代码：

```matlab
function [new_img1 new_img2]=new_rotate(img,angle)
I=imread(img);

[h w d]=size(I);
%计算旋转后图像的大小
new_h=round( w*abs(sind(angle))+h*abs(cosd(angle)) );
new_w=round( w*abs(cosd(angle))+h*abs(sind(angle)) );

new_img1=uint8(zeros(new_h,new_w,d));%uint8是必须的
new_img2=uint8(zeros(new_h,new_w,d));

for x=1:new_w
     for y=1:new_h
         x0=x*cosd(angle) + y*sind(angle) -0.5*new_w*cosd(angle) -0.5*new_h*sind(angle) +0.5*w;        
         y0=-x*sind(angle) + y*cosd(angle) + 0.5*new_w*sind(angle) - 0.5*new_h*cosd(angle)+0.5*h;
         %最邻近插值
         x00=round(x0);
         y00=round(y0);
         if x00>0 && y00>0 &&x00<=w && y00<=h
            %最邻近插值
              new_img1(y,x,:)=I(y00,x00,:);
         end

    if x00>1 && y00>1 &&x00<w && y00<h
        
        x_small=floor(x0);
        x_large=ceil(x0);
        y_small=floor(y0);
        y_large=ceil(y0);
       %双线性插值
       point1=I(y_small,x_small,:) + ( I(y_small,x_large,:) - I(y_small,x_small,:) ) * ( x0 - x_small );
       point2=I(y_large,x_small,:) + ( I(y_large,x_large,:) - I(y_large,x_small,:) ) * ( x0 - x_small );

       point3=point1 + ( point2 - point1 ) * ( y0 - y_small );
       new_img2(y,x,:)=point3;
    end       
end
end

figure,imshow(new_img1),title("最邻近插值");
figure,imshow(new_img2),title("双线性插值");

end
```



#### 2.图像放缩



#### 3.直方图均衡化
#### 4.直方图规定化
#### 5.卷积交换律证明
#### 6.卷积结合律证明
#### 7. 高斯模板生成
#### 8.高斯导数模板生成
#### 9.傅里叶变换实现平滑
#### 10.空域滤波与频域滤波(用实例验证空域滤波可以转换到频率计算,参考大绿书)

参考博客：

http://blog.sciencenet.cn/blog-425437-934155.html

http://blog.sciencenet.cn/blog-425437-1046849.html





#### 11.连通区域标记
#### 12.canny边缘检测

## 二、上一届考题参考（特别鸣谢：某学长）
#### 1.写出灰度图像旋转算法
#### 2.写出灰度图像直方图规定化算法，使得新图像的直方图与一个给定的直方图近似相同
#### 3.写出用频域滤波对一个直方图进行平滑的方法（包括傅里叶变换公式，反变换公式，傅里叶系数的加工处理方式）
#### 4.设S为灰度图像中的一个给定的种子点，由S开始生长出一个连通区域，要求连通区域中的像素与S点的灰度之差在10以内，写出实现该功能的算法


## 三、老师上传到群里的应用练习题的部分解答（写不写看时间）

