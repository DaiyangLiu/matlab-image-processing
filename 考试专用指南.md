##  一、关于作业
#### 1.图像旋转

参考博客：

旋转算法原理：https://blog.csdn.net/liyuan02/article/details/6750828

旋转算法原理及实现：https://blog.csdn.net/lkj345/article/details/50555870

双线性插值：https://www.cnblogs.com/linkr/p/3630902.html

要点：旋转公式、映射关系（前向映射，反向映射）、插值方法（双线性插值（推荐）、最邻近插值）

算法：

```wiki
function rotated_img = my_imrotate(img, angle)   

row,col,d = 获取图像行列以及通道维度 (img）

new_row =根据angle以及row,col 计算旋转后图像的大小的 新 row

new_col = 根据angle以及row,col 计算旋转后图像的大小的 新 col

rotated_img = 为旋转后的图片开辟空间，大小由new_row,new_col,d决定，注意数据格式为uint8


for  x=1:new_col

	for y=1:new_row

		x0= 根据旋转公式（angle,new_row,new_col ）计算出旋转后图中 坐标x 在原始图像中对应的坐标x0

		y0= 根据旋转公式（angle,new_row,new_col ）计算出旋转后图中 坐标y 在原始图像中对应的坐标y0

		x00=  x0四舍五入

		y00=  y0四舍五入

		if  x00>1 && y00>1 && x00<col && y00<row

			x_small= x00向下取整

			x_large= x00向上取整

			y_small= y00向下取整

			y_large= y00向上取整

			point1= 利用双线性插值计算出行数为y_small 列数为x0上的插值(后面最好跟上公式)

			point2= 利用双线性插值计算出行数为y_large 列数为x0上的插值

			point3= 利用双线性插值计算出行数为y0 列数为x0上的插值

			rotate_img[]=point3

		end

	end

end

end
```

代码：

```matlab
function [new_img1 new_img2]=new_rotate(img,angle)
I=imread(img);

[h w d]=size(I);
%计算旋转后图像的大小
new_h=round( w*abs(sind(angle))+h*abs(cosd(angle)) );
new_w=round( w*abs(cosd(angle))+h*abs(sind(angle)) );

new_img1=uint8(zeros(new_h,new_w,d));%uint8是必须的
new_img2=uint8(zeros(new_h,new_w,d));

for x=1:new_w
     for y=1:new_h
         x0=x*cosd(angle) + y*sind(angle) -0.5*new_w*cosd(angle) -0.5*new_h*sind(angle) +0.5*w;        
         y0=-x*sind(angle) + y*cosd(angle) + 0.5*new_w*sind(angle) - 0.5*new_h*cosd(angle)+0.5*h;
         %最邻近插值
         x00=round(x0);
         y00=round(y0);
         if x00>0 && y00>0 &&x00<=w && y00<=h
            %最邻近插值
              new_img1(y,x,:)=I(y00,x00,:);
         end

    if x00>1 && y00>1 &&x00<w && y00<h
        
        x_small=floor(x0);
        x_large=ceil(x0);
        y_small=floor(y0);
        y_large=ceil(y0);
       %双线性插值
       point1=I(y_small,x_small,:) + ( I(y_small,x_large,:) - I(y_small,x_small,:) ) * ( x0 - x_small );
       point2=I(y_large,x_small,:) + ( I(y_large,x_large,:) - I(y_large,x_small,:) ) * ( x0 - x_small );

       point3=point1 + ( point2 - point1 ) * ( y0 - y_small );
       new_img2(y,x,:)=point3;
    end       
end
end

figure,imshow(new_img1),title("最邻近插值");
figure,imshow(new_img2),title("双线性插值");

end
```



#### 2.图像放缩

参考博客：

包含伪代码的放缩：https://blog.csdn.net/huang1024rui/article/details/46545329

有详细讲解的放缩：https://www.cnblogs.com/bigpo/p/4126806.html

要点：双线性插值,图像放缩前后的坐标对应

算法：

```
function resize_img=my_imgresize(img, dst_row, dst_col)

src_row,src_col,d = 从原始图像img获取其行数，列数，通道数

resize_img = 根据dst_row,dst_col,d 为图像放缩的输出开辟空间，注意数据格式应为uint8

for i=1:dst_col

	src_i = 按比例计算得出放缩后 坐标i 对应的原始图像的位置 

	i_small = src_i向下取整

	i_large = src_i 向上取整

	for j=1:dst_row

		src_j = 按比例计算得出放缩后 坐标j 对应的原始图像的位置 

		j_small = src_j 向下取整

		j_large = src_j 向上取整

		if i_small>0 && i_large<=src_row && j_small>0 && j_large<=src_col

				point1 = 根据双线性插值计算出j_small 行中src_i 对应的插值(后面最好跟上公式)

				point2 = 根据双线性插值计算出 j_large 行中src_i 对应的插值

				point3 = 根据双线性插值计算出 src_i （大多数时间为浮点数）列中src_j对应的插值

				resize_img[j,i,:] = point3 

		end

	end

end

end
```



代码：

~~~matlab
function resize_img=my_resize2(img,h,w)
%输入：图片地址，期望图片高度，期望图片宽度
%输出：放缩后的图片
%使用示例：new_img=my_resize2('Boston.jpg',500,800);
I=imread(img);
[src_h,src_w,d]=size(I);
dst_h=h;
dst_w=w;

resize_img=uint8(zeros(dst_h,dst_w,d));

%双线性插值
for i=1:dst_w
    src_i=(i+0.5)*(src_w/dst_w)-0.5;
    i_small=floor(src_i);
    i_large=ceil(src_i);
    src_i=round(src_i);

    for j=1:dst_h
        src_j=(j+0.5)*(src_h/dst_h)-0.5;
        j_small=floor(src_j);
        j_large=ceil(src_j);
        src_j=round(src_j);

            if i_small>0 && i_large<= src_w && j_small>0 && j_large <= src_h
                point1=((i_large-src_i)/(i_large-i_small)) *I(j_small,i_small,:) + 							((src_i-i_small)/(i_large-i_small))*I(j_small,i_large,:);
                point2=((i_large-src_i)/(i_large-i_small)) *I(j_large,i_small,:) + 							((src_i-i_small)/(i_large-i_small))*I(j_large,i_large,:);

                point3=((j_large-src_j)/(j_large-j_small))*point1 + ((src_j-								j_small)/(j_large-j_small))*point2;

                resize_img(j,i,:)= point3;
            end
    end  

end
figure,imshow(I),title("原图");
figure,imtool(resize_img),title("放缩后的图片");

end
~~~



#### 3.直方图均衡化

参考博客：

https://blog.csdn.net/acmore_xiong/article/details/53183131

要点：累积概率直方图，像素映射

算法：

```
function my_histeq(img)

I = 读入图像

cnt = 对每个通道分别统计像素值[0，255]出现的次数

f = 对每个通道分别求像素值[0,255]出现的概率，得到概率直方图。

p =  对每个通道分别求像素值[0,255]概率的前缀和，得到累积概率直方图。

对每个通道根据累计直方图分别求像素映射函数p(k,i)。

对每个通道完成每个像素点的映射p(k, i) = p(k, i) * 255;。
(这里计算完成的 
p(1,1)表示第一通道颜色等级为1的地方均衡化后的颜色等级）

输出直方图均衡化的图像RGB(i, j, k) = p(k, RGB(i, j, k) + 1);。

end
```

代码：

```matlab
RGB = imread('Boston.jpg'); % 读取彩色图
subplot(121);
imshow(RGB);
title('彩色图');

[R, C, K] = size(RGB); % 新增的K表示颜色通道数

% 统计每个像素值出现次数
cnt = zeros(K, 256);
for i = 1 : R
    for j = 1 : C
        for k = 1 : K
            cnt(k, RGB(i, j, k) + 1) = cnt(k, RGB(i, j, k) + 1) + 1;
        end
    end
end

f = zeros(3, 256);
f = double(f); cnt = double(cnt);

% 统计每个像素值出现的概率， 得到概率直方图
for k = 1 : K
    for i = 1 : 256
        f(k, i) = cnt(k, i) / (R * C);
    end
end

% 求累计概率，得到累计直方图
for k = 1 : K
    for i = 2 : 256
        f(k, i) = f(k, i - 1) + f(k, i);
    end
end

% 用f数组实现像素值[0, 255]的映射。 
for k = 1 : K
    for i = 1 : 256
        f(k, i) = f(k, i) * 255;
    end
end

% 完成每个像素点的映射
for i = 1 : R
    for j = 1 : C
        for k = 1 : K
            RGB(i, j, k) = f(k, RGB(i, j, k) + 1);
        end
    end
end

% 输出
RGB = uint8(RGB);
subplot(122);
imshow(RGB);
title('彩色直方图均衡化');
```



#### 4.直方图规定化

参考博客：

代码参考：https://blog.csdn.net/chaolei3/article/details/79734684

要点：

算法：

function my_histspec(img,spec_img)

I=读入原始图像

J=读入规定图像

计算原始图像灰度分布概率

计算规定图像灰度分布概率

计算原始图像的累积概率

计算规定图像的累积概率

for m =1 :256

value{m} = 计算规定图像各灰度的累积概率 与 原图中灰度为m 的差值的绝对值 （vaule{m} 是一个256*1的数组）

index(m) = value{m}中最小值的下标，即找出原始累积概率 与 规定累积概率 最接近的数值，该数值代表着原始图灰度累积概率与规定图灰度累积概率最接近的灰度

end

for 每一个像素点

根据index(m)对原始图的各个像素点赋予新的灰度值

end

end

代码：

```matlab
function new_img = histspec(img,spec_img)
I_=imread(img);
J_=imread(spec_img);
I= rgb2gray(I_);
J= rgb2gray(J_);
[i_h i_w]=size(I);
[j_h j_w]=size(J);

histi=imhist(I);
histj=imhist(J);

%绘制直方图
%figure,imhist(I);
%figure,imhist(J);

%绘制概率分布图
proi=histi/(i_h*i_w);
proj=histj/(j_h*j_w);
%figure,plot(proi);
%figure,plot(proj);

%累积概率
cpi=cumsum(histi)/numel(I);
cpj=cumsum(histj)/numel(J);

%绘制这两幅图的累积概率图
figure,plot(cpi),title('原图累积概率');
figure,plot(cpj),title('标准图累积概率');

%index的下标代表原始图的灰度，值代表映射到标准图上的灰度
for m=1:256
    value{m}=abs(cpj-cpi(m));
    %存下标
    [temp,index(m)]=min(value{m});
    
end

new_img=uint8(zeros(i_h, i_w));

for i =1:i_h
    for j=1:i_w
        new_img(i,j)=index(I(i,j)+1)-1;
    end
end

figure
% 显示图像
subplot(2,3,1);imshow(I);title('原图');
subplot(2,3,2);imshow(J);title('标准图');
subplot(2,3,3);imshow(new_img);title('匹配到标准图');

% 显示灰度直方图
subplot(2,3,4);imhist(I);title('原图');
subplot(2,3,5);imhist(J);title('标准图');
subplot(2,3,6);imhist(new_img);title('直方图匹配到标准图');

end
```



#### 5.卷积交换律证明
#### 6.卷积结合律证明
#### 7. 高斯模板生成
#### 8.高斯导数模板生成
#### 9.傅里叶变换实现平滑
#### 10.空域滤波与频域滤波(用实例验证空域滤波可以转换到频率计算,参考大绿书)

参考博客：

http://blog.sciencenet.cn/blog-425437-934155.html

http://blog.sciencenet.cn/blog-425437-1046849.html



#### 11.连通区域标记
#### 12.canny边缘检测

## 二、上一届考题参考（特别鸣谢：某学长）
#### 1.写出灰度图像旋转算法
#### 2.写出灰度图像直方图规定化算法，使得新图像的直方图与一个给定的直方图近似相同
#### 3.写出用频域滤波对一个直方图进行平滑的方法（包括傅里叶变换公式，反变换公式，傅里叶系数的加工处理方式）
#### 4.设S为灰度图像中的一个给定的种子点，由S开始生长出一个连通区域，要求连通区域中的像素与S点的灰度之差在10以内，写出实现该功能的算法


## 三、老师上传到群里的应用练习题的部分解答（写不写看时间）

